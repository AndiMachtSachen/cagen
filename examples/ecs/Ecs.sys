
contract SafeEcs {
    output wl : int
    output tl : int
    output gate_closed : bool
    output duration : int
    output operate : int
	
	clock timer : int
	
	open -> open :: wl <= tl ==> ! operate
	open -> Closing :: wl > tl ==> operate #timer
	Closing -> Closing :: ! gate_closed & timer < duration ==> true
	Closing -> Closed :: gate_closed ==> true
	Closed -> Closed :: wl > tl ==> ! operate
	Closed -> Opening :: wl <= tl ==> operate #timer
	Opening -> Opening :: gate_closed & timer < duration ==> true
	Opening -> open :: ! gate_closed ==> true
}


contract SafeEcsSkip {
    output wl : int
    output tl : int
    output gate_closed : bool
    output duration : int
    output operate : int
	
	clock timer : int
	
	open -> open :: wl <= tl ==> true
	open -> Closing :: wl > tl & ! gate_closed ==> true #timer
	open -> Closed :: wl > tl & gate_closed ==> true #timer
	Closing -> Closing :: ! gate_closed ==> timer < duration
	Closing -> Closed :: gate_closed ==> true
	Closed -> Closed :: wl > tl ==> true
	Closed -> Opening :: wl <= tl & gate_closed ==> true #timer
	Closed -> open :: wl <= tl & ! gate_closed ==> true #timer
	Opening -> Opening :: gate_closed ==> timer < duration
	Opening -> open :: ! gate_closed ==> true
}

contract EcsOperate {
    output wl : int
    output tl : int
    output gate_closed : bool
    output duration : int
    output operate : int
	
	clock timer : int
	
	open -> open :: wl <= tl ==> ! operate
	open -> Closing :: wl > tl ==> operate #timer
	Closing -> Closing :: ! gate_closed & timer < duration ==> true
	Closing -> closed :: gate_closed ==> true
	closed -> closed :: wl > tl ==> ! operate
	closed -> Opening :: wl <= tl ==> operate #timer
	Opening -> Opening :: gate_closed & timer < duration ==> true
	Opening -> open :: ! gate_closed ==> true
}

contract NonDetEcs {
    output wl : int
    output tl : int
    output gate_closed : bool
    output duration : int
	
	clock timer : int
	
	open -> open :: wl <= tl ==> true
	open -> Closing :: wl >= tl ==> true #timer
	Closing -> Closing :: ! gate_closed ==> timer < duration
	Closing -> closed :: gate_closed ==> true
	closed -> closed :: wl >= tl ==> true
	closed -> Opening :: wl <= tl ==> true #timer
	Opening -> Opening :: gate_closed ==> timer < duration
	Opening -> open :: ! gate_closed ==> true	
}

reactor Ecs  {
	input chw : int
    output wl : int
    output tl : int
    output duration : int
    output gate_closed : bool
    output operate : bool
	
	output target_lvl : int
	
    contract SafeEcs[wl <- wl]
    contract SafeEcsSkip[wl <- wl]
    contract EcsOperate[wl <- wl]
    contract NonDetEcs[wl <- wl]

    {=
		duration = 15;
		tl = 50;
		
		std::this_thread::sleep_for(std::chrono::milliseconds(std::rand() % 10));
		
		if(wl == target_lvl) {
			target_lvl = std::rand() % 10 + 20;
			if(std::rand() % 2){
				target_lvl = 2 * tl - target_lvl;
			}
		}
		if(wl > target_lvl)--wl;
		else ++wl;
		
		operate = (gate_closed != (wl > tl));
		gate_closed = wl > tl;
    =}
}

reactor FluctuateEcs  {
	input chw : int
    output wl : int
    output tl : int
    output duration : int
    output gate_closed : bool
    output operate : bool
	
    contract SafeEcs[wl <- wl]
    contract SafeEcsSkip[wl <- wl]

    {=
		std::this_thread::sleep_for(std::chrono::milliseconds(std::rand() % 10));
		
		tl = 50;
		duration = 15;
		wl += (chw % 10) - 4 - (wl > tl);
		operate = (gate_closed != (wl > tl));
		gate_closed = wl > tl;
    =}
}



reactor DelayEcs  {
	input chw : int
    output wl : int
    output tl : int
    output duration : int
    output gate_closed : bool
    output gate_closed_next_1 : bool
    output gate_closed_next_2 : bool
	output target_lvl : int
    output operate : bool
	
    contract SafeEcs[wl <- wl]
    contract SafeEcsSkip[wl <- wl]

    {=
		duration = 15;
		tl = 50;
		
		std::this_thread::sleep_for(std::chrono::milliseconds(std::rand() % 10));
		
		if(wl == target_lvl) {
			target_lvl = std::rand() % 10 + 20;
			if(std::rand() % 2){
				target_lvl = 2 * tl - target_lvl;
			}
		}
		if(wl > target_lvl)--wl;
		else ++wl;
		
		operate = (gate_closed != (wl > tl)) || (gate_closed_next_1 != (wl > tl)) || (gate_closed_next_2 != (wl > tl));
		gate_closed = gate_closed_next_1;
		gate_closed_next_1 = gate_closed_next_2;
		gate_closed_next_2 = wl > tl;
    =}
}
