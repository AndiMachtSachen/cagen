contract Interval {
    output y : int
    a -> a :: TRUE ==> -0sd32_10 <= y & y <= 0sd32_10
}

contract UpDown {
    input  tick : bool
    output cnt  : int
    
	clock timer : int
	
    history cnt(1)
    history timer(3)

    uP -> uP ::  t_e < 1020 & tick ==> -0sd32_10 < cnt & h_cnt_1 < cnt & cnt < 0sd32_10
    uP -> uP :: ! tick ==> h_cnt_1 = cnt

    DOWN -> DOWN ::  tick ==> h_cnt_1 > cnt & cnt > -0sd32_10
    DOWN -> DOWN :: ! tick ==> h_cnt_1 = cnt

    uP -> DOWN :: t_e < 1020 & tick | timer_e = 0 ==> cnt = 0sd32_10 # timer
    DOWN -> uP :: tick ==> cnt =-0sd32_10 # timer
	
	uP -> COUNT_TWO :: cnt = 2 ==> t_s < 100 #timer
	
	uP -> ZERO :: t_e = 0 ==> true
	
	uP -> MIN_E :: t_e < 10 ==> true
	uP -> MIN_S :: t_s < 10 ==> true
	uP -> MIN :: t < 10 ==> true
	
	uP -> H1_TIMER_E_0 :: h_timer_e_1 = 0 ==> true
	uP -> H2_TIMER_E_0 :: h_timer_e_2 = 0 ==> true
	uP -> H2_TIMER_S_0 :: h_timer_s_2 = 0 ==> true
	uP -> H3_TIMER_E_0 :: h_timer_e_3 = 0 ==> true
	
	uP -> H0_TIMER_S_50 :: timer_s = 50 ==> true
	uP -> H1_TIMER_S_50 :: h_timer_s_1 = 50 ==> true
	uP -> H2_TIMER_S_50 :: h_timer_s_2 = 50 ==> true
	uP -> H3_TIMER_S_50 :: h_timer_s_3 = 50 ==> true
	
	DOWN -> H0_TIMER_S_50 :: timer_s = 50 ==> true
	DOWN -> H1_TIMER_S_50 :: h_timer_s_1 = 50 ==> true
	DOWN -> H2_TIMER_S_50 :: h_timer_s_2 = 50 ==> true
	DOWN -> H3_TIMER_S_50 :: h_timer_s_3 = 50 ==> true
	
	
    contract Interval[y <- cnt]
}


reactor Counter  {
    input  tick : bool
    output val : int
    state  down : bool

    contract UpDown[cnt <- val, tick <- tick]

    {=
        if(tick) {
			if(!down) {
				val += 1;
			} else {
				val -= 1;
			}

			if(val == 10 || val == -10) down = !down;
        }
		std::this_thread::sleep_for(std::chrono::milliseconds(std::rand() % 50));
    =}
}


reactor CounterBroken  {
    input  tick : bool
    output val : int
    state  down : bool

    contract UpDown[cnt <- val, tick <- tick]

    {=
        if(!down) val += 1;
        else      val -= 1;
        if(val == 10 || val == -10) down = !down;
    =}
}




