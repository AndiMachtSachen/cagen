contract Interval {
    output y : int
    a -> a :: TRUE ==> -0sd32_128 <= y & y <= 0sd32_128
}

contract UpDown {
    input  tick : bool
    output cnt  : int
    
    history cnt(1)

    UP -> UP ::  te < 1020 & tick ==> -0sd32_128 < cnt & h_cnt_1 < cnt & cnt < 0sd32_128
    UP -> UP :: ! tick ==> h_cnt_1 = cnt

    DOWN -> DOWN ::  tick ==> h_cnt_1 > cnt & cnt > -0sd32_128
    DOWN -> DOWN :: ! tick ==> h_cnt_1 = cnt

    UP -> DOWN :: te < 1020 & tick ==> cnt = 0sd32_128
    DOWN -> UP :: tick ==> cnt =-0sd32_128

    contract Interval[y <- cnt]
}


reactor Counter  {
    input  tick : bool
    output val : int
    state  down : bool

    contract UpDown[cnt <- val, tick <- tick]

    {=
        if(tick) {
			if(!down) {
				val += 1;
			} else {
				val -= 1;
			}

			if(val == 128 || val == -128) down = !down;
        }
		std::this_thread::sleep_for(std::chrono::milliseconds(std::rand() % 50));
    =}
}


reactor CounterBroken  {
    input  tick : bool
    output val : int
    state  down : bool

    contract UpDown[cnt <- val, tick <- tick]

    {=
        if(!down) val += 1;
        else      val -= 1;
        if(val == 128 || val == -128) down = !down;
    =}
}